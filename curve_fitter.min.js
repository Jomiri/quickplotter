!function(f){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=f();else if("function"==typeof define&&define.amd)define([],f);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).curveFit=f()}}(function(){return function(){return function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){return o(e[i][1][r]||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}}()({1:[function(require,module,exports){const levenbergMarquardt=require("ml-levenberg-marquardt");module.exports.levenbergMarquardt=levenbergMarquardt},{"ml-levenberg-marquardt":5}],2:[function(require,module,exports){"use strict";module.exports=function(input){if(!Array.isArray(input))throw new Error("input must be an array");if(0===input.length)throw new Error("input must not be empty");for(var max=input[0],i=1;i<input.length;i++)input[i]>max&&(max=input[i]);return max}},{}],3:[function(require,module,exports){"use strict";module.exports=function(input){if(!Array.isArray(input))throw new Error("input must be an array");if(0===input.length)throw new Error("input must not be empty");for(var min=input[0],i=1;i<input.length;i++)input[i]<min&&(min=input[i]);return min}},{}],4:[function(require,module,exports){"use strict";function _interopDefault(ex){return ex&&"object"==typeof ex&&"default"in ex?ex.default:ex}var max=_interopDefault(require("ml-array-max")),min=_interopDefault(require("ml-array-min"));module.exports=function(input,options={}){if(!Array.isArray(input))throw new TypeError("input must be an array");if(0===input.length)throw new TypeError("input must not be empty");let output;if(void 0!==options.output){if(!Array.isArray(options.output))throw new TypeError("output option must be an array if specified");output=options.output}else output=new Array(input.length);const currentMin=min(input),currentMax=max(input);if(currentMin===currentMax)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");const{min:minValue=(options.autoMinMax?currentMin:0),max:maxValue=(options.autoMinMax?currentMax:1)}=options;if(minValue>=maxValue)throw new RangeError("min option must be smaller than max option");const factor=(maxValue-minValue)/(currentMax-currentMin);for(var i=0;i<input.length;i++)output[i]=(input[i]-currentMin)*factor+minValue;return output}},{"ml-array-max":2,"ml-array-min":3}],5:[function(require,module,exports){"use strict";var mlMatrix=require("ml-matrix");function errorCalculation(data,parameters,parameterizedFunction){var error=0;const func=parameterizedFunction(parameters);for(var i=0;i<data.x.length;i++)error+=Math.abs(data.y[i]-func(data.x[i]));return error}function step(data,params,damping,gradientDifference,parameterizedFunction){var identity=mlMatrix.Matrix.eye(params.length).mul(damping*gradientDifference*gradientDifference),l=data.x.length,evaluatedData=new Array(l);const func=parameterizedFunction(params);for(var i=0;i<l;i++)evaluatedData[i]=func(data.x[i]);var gradientFunc=function(data,evaluatedData,params,gradientDifference,paramFunction){const n=params.length,m=data.x.length;for(var ans=new Array(n),param=0;param<n;param++){ans[param]=new Array(m);var auxParams=params.concat();auxParams[param]+=gradientDifference;for(var funcParam=paramFunction(auxParams),point=0;point<m;point++)ans[param][point]=evaluatedData[point]-funcParam(data.x[point])}return new mlMatrix.Matrix(ans)}(data,evaluatedData,params,gradientDifference,parameterizedFunction),matrixFunc=function(data,evaluatedData){const m=data.x.length;for(var ans=new Array(m),point=0;point<m;point++)ans[point]=data.y[point]-evaluatedData[point];return new mlMatrix.Matrix([ans])}(data,evaluatedData).transposeView(),inverseMatrix=mlMatrix.inverse(identity.add(gradientFunc.mmul(gradientFunc.transposeView())));return(params=(params=new mlMatrix.Matrix([params])).sub(inverseMatrix.mmul(gradientFunc).mmul(matrixFunc).mul(gradientDifference).transposeView())).to1DArray()}module.exports=function(data,parameterizedFunction,options={}){let{maxIterations=100,gradientDifference=.1,damping=0,errorTolerance=.01,initialValues}=options;if(damping<=0)throw new Error("The damping option must be a positive number");if(!data.x||!data.y)throw new Error("The data parameter must have x and y elements");if(!Array.isArray(data.x)||data.x.length<2||!Array.isArray(data.y)||data.y.length<2)throw new Error("The data parameter elements must be an array with more than 2 points");if(data.x.length!==data.y.length)throw new Error("The data parameter elements must have the same size");var parameters=initialValues||new Array(parameterizedFunction.length).fill(1);if(!Array.isArray(parameters))throw new Error("initialValues must be an array");for(var error=errorCalculation(data,parameters,parameterizedFunction),converged=error<=errorTolerance,iteration=0;iteration<maxIterations&&!converged;iteration++)converged=(error=errorCalculation(data,parameters=step(data,parameters,damping,gradientDifference,parameterizedFunction),parameterizedFunction))<=errorTolerance;return{parameterValues:parameters,parameterError:error,iterations:iteration}}},{"ml-matrix":6}],6:[function(require,module,exports){"use strict";function _interopDefault(ex){return ex&&"object"==typeof ex&&"default"in ex?ex.default:ex}Object.defineProperty(exports,"__esModule",{value:!0});var rescale=_interopDefault(require("ml-array-rescale")),max=_interopDefault(require("ml-array-max"));class LuDecomposition$$1{constructor(matrix){var i,j,k,p,s,t,v,LUcolj,kmax,lu=(matrix=WrapperMatrix2D.checkMatrix(matrix)).clone(),rows=lu.rows,columns=lu.columns,pivotVector=new Array(rows),pivotSign=1;for(i=0;i<rows;i++)pivotVector[i]=i;for(LUcolj=new Array(rows),j=0;j<columns;j++){for(i=0;i<rows;i++)LUcolj[i]=lu.get(i,j);for(i=0;i<rows;i++){for(kmax=Math.min(i,j),s=0,k=0;k<kmax;k++)s+=lu.get(i,k)*LUcolj[k];LUcolj[i]-=s,lu.set(i,j,LUcolj[i])}for(p=j,i=j+1;i<rows;i++)Math.abs(LUcolj[i])>Math.abs(LUcolj[p])&&(p=i);if(p!==j){for(k=0;k<columns;k++)t=lu.get(p,k),lu.set(p,k,lu.get(j,k)),lu.set(j,k,t);v=pivotVector[p],pivotVector[p]=pivotVector[j],pivotVector[j]=v,pivotSign=-pivotSign}if(j<rows&&0!==lu.get(j,j))for(i=j+1;i<rows;i++)lu.set(i,j,lu.get(i,j)/lu.get(j,j))}this.LU=lu,this.pivotVector=pivotVector,this.pivotSign=pivotSign}isSingular(){for(var data=this.LU,col=data.columns,j=0;j<col;j++)if(0===data[j][j])return!0;return!1}solve(value){value=Matrix.checkMatrix(value);var lu=this.LU;if(lu.rows!==value.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");var i,j,k,count=value.columns,X=value.subMatrixRow(this.pivotVector,0,count-1),columns=lu.columns;for(k=0;k<columns;k++)for(i=k+1;i<columns;i++)for(j=0;j<count;j++)X[i][j]-=X[k][j]*lu[i][k];for(k=columns-1;k>=0;k--){for(j=0;j<count;j++)X[k][j]/=lu[k][k];for(i=0;i<k;i++)for(j=0;j<count;j++)X[i][j]-=X[k][j]*lu[i][k]}return X}get determinant(){var data=this.LU;if(!data.isSquare())throw new Error("Matrix must be square");for(var determinant=this.pivotSign,col=data.columns,j=0;j<col;j++)determinant*=data[j][j];return determinant}get lowerTriangularMatrix(){for(var data=this.LU,rows=data.rows,columns=data.columns,X=new Matrix(rows,columns),i=0;i<rows;i++)for(var j=0;j<columns;j++)X[i][j]=i>j?data[i][j]:i===j?1:0;return X}get upperTriangularMatrix(){for(var data=this.LU,rows=data.rows,columns=data.columns,X=new Matrix(rows,columns),i=0;i<rows;i++)for(var j=0;j<columns;j++)X[i][j]=i<=j?data[i][j]:0;return X}get pivotPermutationVector(){return this.pivotVector.slice()}}function hypotenuse(a,b){var r=0;return Math.abs(a)>Math.abs(b)?(r=b/a,Math.abs(a)*Math.sqrt(1+r*r)):0!==b?(r=a/b,Math.abs(b)*Math.sqrt(1+r*r)):0}function getFilled2DArray(rows,columns,value){for(var array=new Array(rows),i=0;i<rows;i++){array[i]=new Array(columns);for(var j=0;j<columns;j++)array[i][j]=value}return array}class SingularValueDecomposition$$1{constructor(value,options={}){var m=(value=WrapperMatrix2D.checkMatrix(value)).rows,n=value.columns;const{computeLeftSingularVectors=!0,computeRightSingularVectors=!0,autoTranspose=!1}=options;var a,wantu=Boolean(computeLeftSingularVectors),wantv=Boolean(computeRightSingularVectors),swapped=!1;if(m<n)if(autoTranspose){m=(a=value.transpose()).rows,n=a.columns,swapped=!0;var aux=wantu;wantu=wantv,wantv=aux}else a=value.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else a=value.clone();var nu=Math.min(m,n),ni=Math.min(m+1,n),s=new Array(ni),U=getFilled2DArray(m,nu,0),V=getFilled2DArray(n,n,0),e=new Array(n),work=new Array(m),si=new Array(ni);for(let i=0;i<ni;i++)si[i]=i;var nct=Math.min(m-1,n),nrt=Math.max(0,Math.min(n-2,m)),mrc=Math.max(nct,nrt);for(let k=0;k<mrc;k++){if(k<nct){s[k]=0;for(let i=k;i<m;i++)s[k]=hypotenuse(s[k],a[i][k]);if(0!==s[k]){a[k][k]<0&&(s[k]=-s[k]);for(let i=k;i<m;i++)a[i][k]/=s[k];a[k][k]+=1}s[k]=-s[k]}for(let j=k+1;j<n;j++){if(k<nct&&0!==s[k]){let t=0;for(let i=k;i<m;i++)t+=a[i][k]*a[i][j];t=-t/a[k][k];for(let i=k;i<m;i++)a[i][j]+=t*a[i][k]}e[j]=a[k][j]}if(wantu&&k<nct)for(let i=k;i<m;i++)U[i][k]=a[i][k];if(k<nrt){e[k]=0;for(let i=k+1;i<n;i++)e[k]=hypotenuse(e[k],e[i]);if(0!==e[k]){e[k+1]<0&&(e[k]=0-e[k]);for(let i=k+1;i<n;i++)e[i]/=e[k];e[k+1]+=1}if(e[k]=-e[k],k+1<m&&0!==e[k]){for(let i=k+1;i<m;i++)work[i]=0;for(let i=k+1;i<m;i++)for(let j=k+1;j<n;j++)work[i]+=e[j]*a[i][j];for(let j=k+1;j<n;j++){let t=-e[j]/e[k+1];for(let i=k+1;i<m;i++)a[i][j]+=t*work[i]}}if(wantv)for(let i=k+1;i<n;i++)V[i][k]=e[i]}}let p=Math.min(n,m+1);if(nct<n&&(s[nct]=a[nct][nct]),m<p&&(s[p-1]=0),nrt+1<p&&(e[nrt]=a[nrt][p-1]),e[p-1]=0,wantu){for(let j=nct;j<nu;j++){for(let i=0;i<m;i++)U[i][j]=0;U[j][j]=1}for(let k=nct-1;k>=0;k--)if(0!==s[k]){for(let j=k+1;j<nu;j++){let t=0;for(let i=k;i<m;i++)t+=U[i][k]*U[i][j];t=-t/U[k][k];for(let i=k;i<m;i++)U[i][j]+=t*U[i][k]}for(let i=k;i<m;i++)U[i][k]=-U[i][k];U[k][k]=1+U[k][k];for(let i=0;i<k-1;i++)U[i][k]=0}else{for(let i=0;i<m;i++)U[i][k]=0;U[k][k]=1}}if(wantv)for(let k=n-1;k>=0;k--){if(k<nrt&&0!==e[k])for(let j=k+1;j<n;j++){let t=0;for(let i=k+1;i<n;i++)t+=V[i][k]*V[i][j];t=-t/V[k+1][k];for(let i=k+1;i<n;i++)V[i][j]+=t*V[i][k]}for(let i=0;i<n;i++)V[i][k]=0;V[k][k]=1}for(var pp=p-1,eps=Number.EPSILON;p>0;){let k,kase;for(k=p-2;k>=-1&&-1!==k;k--){const alpha=Number.MIN_VALUE+eps*Math.abs(s[k]+Math.abs(s[k+1]));if(Math.abs(e[k])<=alpha||Number.isNaN(e[k])){e[k]=0;break}}if(k===p-2)kase=4;else{let ks;for(ks=p-1;ks>=k&&ks!==k;ks--){let t=(ks!==p?Math.abs(e[ks]):0)+(ks!==k+1?Math.abs(e[ks-1]):0);if(Math.abs(s[ks])<=eps*t){s[ks]=0;break}}ks===k?kase=3:ks===p-1?kase=1:(kase=2,k=ks)}switch(k++,kase){case 1:{let f=e[p-2];e[p-2]=0;for(let j=p-2;j>=k;j--){let t=hypotenuse(s[j],f),cs=s[j]/t,sn=f/t;if(s[j]=t,j!==k&&(f=-sn*e[j-1],e[j-1]=cs*e[j-1]),wantv)for(let i=0;i<n;i++)t=cs*V[i][j]+sn*V[i][p-1],V[i][p-1]=-sn*V[i][j]+cs*V[i][p-1],V[i][j]=t}break}case 2:{let f=e[k-1];e[k-1]=0;for(let j=k;j<p;j++){let t=hypotenuse(s[j],f),cs=s[j]/t,sn=f/t;if(s[j]=t,f=-sn*e[j],e[j]=cs*e[j],wantu)for(let i=0;i<m;i++)t=cs*U[i][j]+sn*U[i][k-1],U[i][k-1]=-sn*U[i][j]+cs*U[i][k-1],U[i][j]=t}break}case 3:{const scale=Math.max(Math.abs(s[p-1]),Math.abs(s[p-2]),Math.abs(e[p-2]),Math.abs(s[k]),Math.abs(e[k])),sp=s[p-1]/scale,spm1=s[p-2]/scale,epm1=e[p-2]/scale,sk=s[k]/scale,ek=e[k]/scale,b=((spm1+sp)*(spm1-sp)+epm1*epm1)/2,c=sp*epm1*(sp*epm1);let shift=0;0===b&&0===c||(shift=c/(b+(shift=b<0?0-Math.sqrt(b*b+c):Math.sqrt(b*b+c))));let f=(sk+sp)*(sk-sp)+shift,g=sk*ek;for(let j=k;j<p-1;j++){let t=hypotenuse(f,g);0===t&&(t=Number.MIN_VALUE);let cs=f/t,sn=g/t;if(j!==k&&(e[j-1]=t),f=cs*s[j]+sn*e[j],e[j]=cs*e[j]-sn*s[j],g=sn*s[j+1],s[j+1]=cs*s[j+1],wantv)for(let i=0;i<n;i++)t=cs*V[i][j]+sn*V[i][j+1],V[i][j+1]=-sn*V[i][j]+cs*V[i][j+1],V[i][j]=t;if(0===(t=hypotenuse(f,g))&&(t=Number.MIN_VALUE),cs=f/t,sn=g/t,s[j]=t,f=cs*e[j]+sn*s[j+1],s[j+1]=-sn*e[j]+cs*s[j+1],g=sn*e[j+1],e[j+1]=cs*e[j+1],wantu&&j<m-1)for(let i=0;i<m;i++)t=cs*U[i][j]+sn*U[i][j+1],U[i][j+1]=-sn*U[i][j]+cs*U[i][j+1],U[i][j]=t}e[p-2]=f;break}case 4:if(s[k]<=0&&(s[k]=s[k]<0?-s[k]:0,wantv))for(let i=0;i<=pp;i++)V[i][k]=-V[i][k];for(;k<pp&&!(s[k]>=s[k+1]);){let t=s[k];if(s[k]=s[k+1],s[k+1]=t,wantv&&k<n-1)for(let i=0;i<n;i++)t=V[i][k+1],V[i][k+1]=V[i][k],V[i][k]=t;if(wantu&&k<m-1)for(let i=0;i<m;i++)t=U[i][k+1],U[i][k+1]=U[i][k],U[i][k]=t;k++}p--}}if(swapped){var tmp=V;V=U,U=tmp}this.m=m,this.n=n,this.s=s,this.U=U,this.V=V}solve(value){var Y=value,e=this.threshold,scols=this.s.length,Ls=Matrix.zeros(scols,scols);for(let i=0;i<scols;i++)Math.abs(this.s[i])<=e?Ls[i][i]=0:Ls[i][i]=1/this.s[i];var U=this.U,V=this.rightSingularVectors,VL=V.mmul(Ls),vrows=V.rows,urows=U.length,VLU=Matrix.zeros(vrows,urows);for(let i=0;i<vrows;i++)for(let j=0;j<urows;j++){let sum=0;for(let k=0;k<scols;k++)sum+=VL[i][k]*U[j][k];VLU[i][j]=sum}return VLU.mmul(Y)}solveForDiagonal(value){return this.solve(Matrix.diag(value))}inverse(){var V=this.V,e=this.threshold,vrows=V.length,vcols=V[0].length,X=new Matrix(vrows,this.s.length);for(let i=0;i<vrows;i++)for(let j=0;j<vcols;j++)Math.abs(this.s[j])>e?X[i][j]=V[i][j]/this.s[j]:X[i][j]=0;var U=this.U,urows=U.length,ucols=U[0].length,Y=new Matrix(vrows,urows);for(let i=0;i<vrows;i++)for(let j=0;j<urows;j++){let sum=0;for(let k=0;k<ucols;k++)sum+=X[i][k]*U[j][k];Y[i][j]=sum}return Y}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){for(var tol=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,r=0,s=this.s,i=0,ii=s.length;i<ii;i++)s[i]>tol&&r++;return r}get diagonal(){return this.s}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return Matrix.isMatrix(this.U)||(this.U=new Matrix(this.U)),this.U}get rightSingularVectors(){return Matrix.isMatrix(this.V)||(this.V=new Matrix(this.V)),this.V}get diagonalMatrix(){return Matrix.diag(this.s)}}function checkRowIndex(matrix,index,outer){var max$$1=outer?matrix.rows:matrix.rows-1;if(index<0||index>max$$1)throw new RangeError("Row index out of range")}function checkColumnIndex(matrix,index,outer){var max$$1=outer?matrix.columns:matrix.columns-1;if(index<0||index>max$$1)throw new RangeError("Column index out of range")}function checkRowVector(matrix,vector){if(vector.to1DArray&&(vector=vector.to1DArray()),vector.length!==matrix.columns)throw new RangeError("vector size must be the same as the number of columns");return vector}function checkColumnVector(matrix,vector){if(vector.to1DArray&&(vector=vector.to1DArray()),vector.length!==matrix.rows)throw new RangeError("vector size must be the same as the number of rows");return vector}function checkIndices(matrix,rowIndices,columnIndices){return{row:checkRowIndices(matrix,rowIndices),column:checkColumnIndices(matrix,columnIndices)}}function checkRowIndices(matrix,rowIndices){if("object"!=typeof rowIndices)throw new TypeError("unexpected type for row indices");if(rowIndices.some(r=>r<0||r>=matrix.rows))throw new RangeError("row indices are out of range");return Array.isArray(rowIndices)||(rowIndices=Array.from(rowIndices)),rowIndices}function checkColumnIndices(matrix,columnIndices){if("object"!=typeof columnIndices)throw new TypeError("unexpected type for column indices");if(columnIndices.some(c=>c<0||c>=matrix.columns))throw new RangeError("column indices are out of range");return Array.isArray(columnIndices)||(columnIndices=Array.from(columnIndices)),columnIndices}function checkRange(matrix,startRow,endRow,startColumn,endColumn){if(5!==arguments.length)throw new RangeError("expected 4 arguments");if(checkNumber("startRow",startRow),checkNumber("endRow",endRow),checkNumber("startColumn",startColumn),checkNumber("endColumn",endColumn),startRow>endRow||startColumn>endColumn||startRow<0||startRow>=matrix.rows||endRow<0||endRow>=matrix.rows||startColumn<0||startColumn>=matrix.columns||endColumn<0||endColumn>=matrix.columns)throw new RangeError("Submatrix indices are out of range")}function sumByRow(matrix){for(var sum=Matrix.zeros(matrix.rows,1),i=0;i<matrix.rows;++i)for(var j=0;j<matrix.columns;++j)sum.set(i,0,sum.get(i,0)+matrix.get(i,j));return sum}function sumByColumn(matrix){for(var sum=Matrix.zeros(1,matrix.columns),i=0;i<matrix.rows;++i)for(var j=0;j<matrix.columns;++j)sum.set(0,j,sum.get(0,j)+matrix.get(i,j));return sum}function checkNumber(name,value){if("number"!=typeof value)throw new TypeError(`${name} must be a number`)}class BaseView extends(AbstractMatrix()){constructor(matrix,rows,columns){super(),this.matrix=matrix,this.rows=rows,this.columns=columns}static get[Symbol.species](){return Matrix}}class MatrixTransposeView extends BaseView{constructor(matrix){super(matrix,matrix.columns,matrix.rows)}set(rowIndex,columnIndex,value){return this.matrix.set(columnIndex,rowIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(columnIndex,rowIndex)}}class MatrixRowView extends BaseView{constructor(matrix,row){super(matrix,1,matrix.columns),this.row=row}set(rowIndex,columnIndex,value){return this.matrix.set(this.row,columnIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(this.row,columnIndex)}}class MatrixSubView extends BaseView{constructor(matrix,startRow,endRow,startColumn,endColumn){checkRange(matrix,startRow,endRow,startColumn,endColumn),super(matrix,endRow-startRow+1,endColumn-startColumn+1),this.startRow=startRow,this.startColumn=startColumn}set(rowIndex,columnIndex,value){return this.matrix.set(this.startRow+rowIndex,this.startColumn+columnIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(this.startRow+rowIndex,this.startColumn+columnIndex)}}class MatrixSelectionView extends BaseView{constructor(matrix,rowIndices,columnIndices){var indices=checkIndices(matrix,rowIndices,columnIndices);super(matrix,indices.row.length,indices.column.length),this.rowIndices=indices.row,this.columnIndices=indices.column}set(rowIndex,columnIndex,value){return this.matrix.set(this.rowIndices[rowIndex],this.columnIndices[columnIndex],value),this}get(rowIndex,columnIndex){return this.matrix.get(this.rowIndices[rowIndex],this.columnIndices[columnIndex])}}class MatrixRowSelectionView extends BaseView{constructor(matrix,rowIndices){super(matrix,(rowIndices=checkRowIndices(matrix,rowIndices)).length,matrix.columns),this.rowIndices=rowIndices}set(rowIndex,columnIndex,value){return this.matrix.set(this.rowIndices[rowIndex],columnIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(this.rowIndices[rowIndex],columnIndex)}}class MatrixColumnSelectionView extends BaseView{constructor(matrix,columnIndices){columnIndices=checkColumnIndices(matrix,columnIndices),super(matrix,matrix.rows,columnIndices.length),this.columnIndices=columnIndices}set(rowIndex,columnIndex,value){return this.matrix.set(rowIndex,this.columnIndices[columnIndex],value),this}get(rowIndex,columnIndex){return this.matrix.get(rowIndex,this.columnIndices[columnIndex])}}class MatrixColumnView extends BaseView{constructor(matrix,column){super(matrix,matrix.rows,1),this.column=column}set(rowIndex,columnIndex,value){return this.matrix.set(rowIndex,this.column,value),this}get(rowIndex){return this.matrix.get(rowIndex,this.column)}}class MatrixFlipRowView extends BaseView{constructor(matrix){super(matrix,matrix.rows,matrix.columns)}set(rowIndex,columnIndex,value){return this.matrix.set(this.rows-rowIndex-1,columnIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(this.rows-rowIndex-1,columnIndex)}}class MatrixFlipColumnView extends BaseView{constructor(matrix){super(matrix,matrix.rows,matrix.columns)}set(rowIndex,columnIndex,value){return this.matrix.set(rowIndex,this.columns-columnIndex-1,value),this}get(rowIndex,columnIndex){return this.matrix.get(rowIndex,this.columns-columnIndex-1)}}function AbstractMatrix(superCtor){void 0===superCtor&&(superCtor=Object);class Matrix extends superCtor{static get[Symbol.species](){return this}static from1DArray(newRows,newColumns,newData){if(newRows*newColumns!==newData.length)throw new RangeError("Data length does not match given dimensions");for(var newMatrix=new this(newRows,newColumns),row=0;row<newRows;row++)for(var column=0;column<newColumns;column++)newMatrix.set(row,column,newData[row*newColumns+column]);return newMatrix}static rowVector(newData){for(var vector=new this(1,newData.length),i=0;i<newData.length;i++)vector.set(0,i,newData[i]);return vector}static columnVector(newData){for(var vector=new this(newData.length,1),i=0;i<newData.length;i++)vector.set(i,0,newData[i]);return vector}static empty(rows,columns){return new this(rows,columns)}static zeros(rows,columns){return this.empty(rows,columns).fill(0)}static ones(rows,columns){return this.empty(rows,columns).fill(1)}static rand(rows,columns,rng){void 0===rng&&(rng=Math.random);for(var matrix=this.empty(rows,columns),i=0;i<rows;i++)for(var j=0;j<columns;j++)matrix.set(i,j,rng());return matrix}static randInt(rows,columns,maxValue,rng){void 0===maxValue&&(maxValue=1e3),void 0===rng&&(rng=Math.random);for(var matrix=this.empty(rows,columns),i=0;i<rows;i++)for(var j=0;j<columns;j++){var value=Math.floor(rng()*maxValue);matrix.set(i,j,value)}return matrix}static eye(rows,columns,value){void 0===columns&&(columns=rows),void 0===value&&(value=1);for(var min=Math.min(rows,columns),matrix=this.zeros(rows,columns),i=0;i<min;i++)matrix.set(i,i,value);return matrix}static diag(data,rows,columns){var l=data.length;void 0===rows&&(rows=l),void 0===columns&&(columns=rows);for(var min=Math.min(l,rows,columns),matrix=this.zeros(rows,columns),i=0;i<min;i++)matrix.set(i,i,data[i]);return matrix}static min(matrix1,matrix2){matrix1=this.checkMatrix(matrix1),matrix2=this.checkMatrix(matrix2);for(var rows=matrix1.rows,columns=matrix1.columns,result=new this(rows,columns),i=0;i<rows;i++)for(var j=0;j<columns;j++)result.set(i,j,Math.min(matrix1.get(i,j),matrix2.get(i,j)));return result}static max(matrix1,matrix2){matrix1=this.checkMatrix(matrix1),matrix2=this.checkMatrix(matrix2);for(var rows=matrix1.rows,columns=matrix1.columns,result=new this(rows,columns),i=0;i<rows;i++)for(var j=0;j<columns;j++)result.set(i,j,Math.max(matrix1.get(i,j),matrix2.get(i,j)));return result}static checkMatrix(value){return Matrix.isMatrix(value)?value:new this(value)}static isMatrix(value){return null!=value&&"Matrix"===value.klass}get size(){return this.rows*this.columns}apply(callback){if("function"!=typeof callback)throw new TypeError("callback must be a function");for(var ii=this.rows,jj=this.columns,i=0;i<ii;i++)for(var j=0;j<jj;j++)callback.call(this,i,j);return this}to1DArray(){for(var array=new Array(this.size),i=0;i<this.rows;i++)for(var j=0;j<this.columns;j++)array[i*this.columns+j]=this.get(i,j);return array}to2DArray(){for(var copy=new Array(this.rows),i=0;i<this.rows;i++){copy[i]=new Array(this.columns);for(var j=0;j<this.columns;j++)copy[i][j]=this.get(i,j)}return copy}isRowVector(){return 1===this.rows}isColumnVector(){return 1===this.columns}isVector(){return 1===this.rows||1===this.columns}isSquare(){return this.rows===this.columns}isSymmetric(){if(this.isSquare()){for(var i=0;i<this.rows;i++)for(var j=0;j<=i;j++)if(this.get(i,j)!==this.get(j,i))return!1;return!0}return!1}set(rowIndex,columnIndex,value){throw new Error("set method is unimplemented")}get(rowIndex,columnIndex){throw new Error("get method is unimplemented")}repeat(rowRep,colRep){rowRep=rowRep||1,colRep=colRep||1;for(var matrix=new this.constructor[Symbol.species](this.rows*rowRep,this.columns*colRep),i=0;i<rowRep;i++)for(var j=0;j<colRep;j++)matrix.setSubMatrix(this,this.rows*i,this.columns*j);return matrix}fill(value){for(var i=0;i<this.rows;i++)for(var j=0;j<this.columns;j++)this.set(i,j,value);return this}neg(){return this.mulS(-1)}getRow(index){checkRowIndex(this,index);for(var row=new Array(this.columns),i=0;i<this.columns;i++)row[i]=this.get(index,i);return row}getRowVector(index){return this.constructor.rowVector(this.getRow(index))}setRow(index,array){checkRowIndex(this,index),array=checkRowVector(this,array);for(var i=0;i<this.columns;i++)this.set(index,i,array[i]);return this}swapRows(row1,row2){checkRowIndex(this,row1),checkRowIndex(this,row2);for(var i=0;i<this.columns;i++){var temp=this.get(row1,i);this.set(row1,i,this.get(row2,i)),this.set(row2,i,temp)}return this}getColumn(index){checkColumnIndex(this,index);for(var column=new Array(this.rows),i=0;i<this.rows;i++)column[i]=this.get(i,index);return column}getColumnVector(index){return this.constructor.columnVector(this.getColumn(index))}setColumn(index,array){checkColumnIndex(this,index),array=checkColumnVector(this,array);for(var i=0;i<this.rows;i++)this.set(i,index,array[i]);return this}swapColumns(column1,column2){checkColumnIndex(this,column1),checkColumnIndex(this,column2);for(var i=0;i<this.rows;i++){var temp=this.get(i,column1);this.set(i,column1,this.get(i,column2)),this.set(i,column2,temp)}return this}addRowVector(vector){vector=checkRowVector(this,vector);for(var i=0;i<this.rows;i++)for(var j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)+vector[j]);return this}subRowVector(vector){vector=checkRowVector(this,vector);for(var i=0;i<this.rows;i++)for(var j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)-vector[j]);return this}mulRowVector(vector){vector=checkRowVector(this,vector);for(var i=0;i<this.rows;i++)for(var j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)*vector[j]);return this}divRowVector(vector){vector=checkRowVector(this,vector);for(var i=0;i<this.rows;i++)for(var j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)/vector[j]);return this}addColumnVector(vector){vector=checkColumnVector(this,vector);for(var i=0;i<this.rows;i++)for(var j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)+vector[i]);return this}subColumnVector(vector){vector=checkColumnVector(this,vector);for(var i=0;i<this.rows;i++)for(var j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)-vector[i]);return this}mulColumnVector(vector){vector=checkColumnVector(this,vector);for(var i=0;i<this.rows;i++)for(var j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)*vector[i]);return this}divColumnVector(vector){vector=checkColumnVector(this,vector);for(var i=0;i<this.rows;i++)for(var j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)/vector[i]);return this}mulRow(index,value){checkRowIndex(this,index);for(var i=0;i<this.columns;i++)this.set(index,i,this.get(index,i)*value);return this}mulColumn(index,value){checkColumnIndex(this,index);for(var i=0;i<this.rows;i++)this.set(i,index,this.get(i,index)*value);return this}max(){for(var v=this.get(0,0),i=0;i<this.rows;i++)for(var j=0;j<this.columns;j++)this.get(i,j)>v&&(v=this.get(i,j));return v}maxIndex(){for(var v=this.get(0,0),idx=[0,0],i=0;i<this.rows;i++)for(var j=0;j<this.columns;j++)this.get(i,j)>v&&(v=this.get(i,j),idx[0]=i,idx[1]=j);return idx}min(){for(var v=this.get(0,0),i=0;i<this.rows;i++)for(var j=0;j<this.columns;j++)this.get(i,j)<v&&(v=this.get(i,j));return v}minIndex(){for(var v=this.get(0,0),idx=[0,0],i=0;i<this.rows;i++)for(var j=0;j<this.columns;j++)this.get(i,j)<v&&(v=this.get(i,j),idx[0]=i,idx[1]=j);return idx}maxRow(row){checkRowIndex(this,row);for(var v=this.get(row,0),i=1;i<this.columns;i++)this.get(row,i)>v&&(v=this.get(row,i));return v}maxRowIndex(row){checkRowIndex(this,row);for(var v=this.get(row,0),idx=[row,0],i=1;i<this.columns;i++)this.get(row,i)>v&&(v=this.get(row,i),idx[1]=i);return idx}minRow(row){checkRowIndex(this,row);for(var v=this.get(row,0),i=1;i<this.columns;i++)this.get(row,i)<v&&(v=this.get(row,i));return v}minRowIndex(row){checkRowIndex(this,row);for(var v=this.get(row,0),idx=[row,0],i=1;i<this.columns;i++)this.get(row,i)<v&&(v=this.get(row,i),idx[1]=i);return idx}maxColumn(column){checkColumnIndex(this,column);for(var v=this.get(0,column),i=1;i<this.rows;i++)this.get(i,column)>v&&(v=this.get(i,column));return v}maxColumnIndex(column){checkColumnIndex(this,column);for(var v=this.get(0,column),idx=[0,column],i=1;i<this.rows;i++)this.get(i,column)>v&&(v=this.get(i,column),idx[0]=i);return idx}minColumn(column){checkColumnIndex(this,column);for(var v=this.get(0,column),i=1;i<this.rows;i++)this.get(i,column)<v&&(v=this.get(i,column));return v}minColumnIndex(column){checkColumnIndex(this,column);for(var v=this.get(0,column),idx=[0,column],i=1;i<this.rows;i++)this.get(i,column)<v&&(v=this.get(i,column),idx[0]=i);return idx}diag(){for(var min=Math.min(this.rows,this.columns),diag=new Array(min),i=0;i<min;i++)diag[i]=this.get(i,i);return diag}sum(by){switch(by){case"row":return sumByRow(this);case"column":return sumByColumn(this);default:return function(matrix){for(var v=0,i=0;i<matrix.rows;i++)for(var j=0;j<matrix.columns;j++)v+=matrix.get(i,j);return v}(this)}}mean(){return this.sum()/this.size}prod(){for(var prod=1,i=0;i<this.rows;i++)for(var j=0;j<this.columns;j++)prod*=this.get(i,j);return prod}norm(type="frobenius"){var result=0;if("max"===type)return this.max();if("frobenius"===type){for(var i=0;i<this.rows;i++)for(var j=0;j<this.columns;j++)result+=this.get(i,j)*this.get(i,j);return Math.sqrt(result)}throw new RangeError(`unknown norm type: ${type}`)}cumulativeSum(){for(var sum=0,i=0;i<this.rows;i++)for(var j=0;j<this.columns;j++)sum+=this.get(i,j),this.set(i,j,sum);return this}dot(vector2){Matrix.isMatrix(vector2)&&(vector2=vector2.to1DArray());var vector1=this.to1DArray();if(vector1.length!==vector2.length)throw new RangeError("vectors do not have the same size");for(var dot=0,i=0;i<vector1.length;i++)dot+=vector1[i]*vector2[i];return dot}mmul(other){other=this.constructor.checkMatrix(other),this.columns!==other.rows&&console.warn("Number of columns of left matrix are not equal to number of rows of right matrix.");for(var m=this.rows,n=this.columns,p=other.columns,result=new this.constructor[Symbol.species](m,p),Bcolj=new Array(n),j=0;j<p;j++){for(var k=0;k<n;k++)Bcolj[k]=other.get(k,j);for(var i=0;i<m;i++){var s=0;for(k=0;k<n;k++)s+=this.get(i,k)*Bcolj[k];result.set(i,j,s)}}return result}strassen2x2(other){var result=new this.constructor[Symbol.species](2,2);const a11=this.get(0,0),b11=other.get(0,0),a12=this.get(0,1),b12=other.get(0,1),a21=this.get(1,0),b21=other.get(1,0),a22=this.get(1,1),b22=other.get(1,1),m1=(a11+a22)*(b11+b22),m2=(a21+a22)*b11,m3=a11*(b12-b22),m4=a22*(b21-b11),m5=(a11+a12)*b22,c00=m1+m4-m5+(a12-a22)*(b21+b22),c01=m3+m5,c10=m2+m4,c11=m1-m2+m3+(a21-a11)*(b11+b12);return result.set(0,0,c00),result.set(0,1,c01),result.set(1,0,c10),result.set(1,1,c11),result}strassen3x3(other){var result=new this.constructor[Symbol.species](3,3);const a00=this.get(0,0),a01=this.get(0,1),a02=this.get(0,2),a10=this.get(1,0),a11=this.get(1,1),a12=this.get(1,2),a20=this.get(2,0),a21=this.get(2,1),a22=this.get(2,2),b00=other.get(0,0),b01=other.get(0,1),b02=other.get(0,2),b10=other.get(1,0),b11=other.get(1,1),b12=other.get(1,2),b20=other.get(2,0),b21=other.get(2,1),b22=other.get(2,2),m2=(a00-a10)*(-b01+b11),m4=(-a00+a10+a11)*(b00-b01+b11),m5=(a10+a11)*(-b00+b01),m6=a00*b00,m7=(-a00+a20+a21)*(b00-b02+b12),m8=(-a00+a20)*(b02-b12),m9=(a20+a21)*(-b00+b02),m12=(-a02+a21+a22)*(b11+b20-b21),m13=(a02-a22)*(b11-b21),m14=a02*b20,m15=(a21+a22)*(-b20+b21),m16=(-a02+a11+a12)*(b12+b20-b22),m17=(a02-a12)*(b12-b22),m18=(a11+a12)*(-b20+b22),c00=m6+m14+a01*b10,c01=(a00+a01+a02-a10-a11-a21-a22)*b11+m4+m5+m6+m12+m14+m15,c02=m6+m7+m9+(a00+a01+a02-a11-a12-a20-a21)*b12+m14+m16+m18,c10=m2+a11*(-b00+b01+b10-b11-b12-b20+b22)+m4+m6+m14+m16+m17,c11=m2+m4+m5+m6+a12*b21,c12=m14+m16+m17+m18+a10*b02,c20=m6+m7+m8+a21*(-b00+b02+b10-b11-b12-b20+b21)+m12+m13+m14,c21=m12+m13+m14+m15+a20*b01,c22=m6+m7+m8+m9+a22*b22;return result.set(0,0,c00),result.set(0,1,c01),result.set(0,2,c02),result.set(1,0,c10),result.set(1,1,c11),result.set(1,2,c12),result.set(2,0,c20),result.set(2,1,c21),result.set(2,2,c22),result}mmulStrassen(y){var x=this.clone(),r1=x.rows,c1=x.columns,r2=y.rows,c2=y.columns;function embed(mat,rows,cols){var r=mat.rows,c=mat.columns;if(r===rows&&c===cols)return mat;var resultat=Matrix.zeros(rows,cols);return resultat=resultat.setSubMatrix(mat,0,0)}c1!==r2&&console.warn(`Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`);var r=Math.max(r1,r2),c=Math.max(c1,c2);return function blockMult(a,b,rows,cols){if(rows<=512||cols<=512)return a.mmul(b);rows%2==1&&cols%2==1?(a=embed(a,rows+1,cols+1),b=embed(b,rows+1,cols+1)):rows%2==1?(a=embed(a,rows+1,cols),b=embed(b,rows+1,cols)):cols%2==1&&(a=embed(a,rows,cols+1),b=embed(b,rows,cols+1));var halfRows=parseInt(a.rows/2,10),halfCols=parseInt(a.columns/2,10),a11=a.subMatrix(0,halfRows-1,0,halfCols-1),b11=b.subMatrix(0,halfRows-1,0,halfCols-1),a12=a.subMatrix(0,halfRows-1,halfCols,a.columns-1),b12=b.subMatrix(0,halfRows-1,halfCols,b.columns-1),a21=a.subMatrix(halfRows,a.rows-1,0,halfCols-1),b21=b.subMatrix(halfRows,b.rows-1,0,halfCols-1),a22=a.subMatrix(halfRows,a.rows-1,halfCols,a.columns-1),b22=b.subMatrix(halfRows,b.rows-1,halfCols,b.columns-1),m1=blockMult(Matrix.add(a11,a22),Matrix.add(b11,b22),halfRows,halfCols),m2=blockMult(Matrix.add(a21,a22),b11,halfRows,halfCols),m3=blockMult(a11,Matrix.sub(b12,b22),halfRows,halfCols),m4=blockMult(a22,Matrix.sub(b21,b11),halfRows,halfCols),m5=blockMult(Matrix.add(a11,a12),b22,halfRows,halfCols),m6=blockMult(Matrix.sub(a21,a11),Matrix.add(b11,b12),halfRows,halfCols),m7=blockMult(Matrix.sub(a12,a22),Matrix.add(b21,b22),halfRows,halfCols),c11=Matrix.add(m1,m4);c11.sub(m5),c11.add(m7);var c12=Matrix.add(m3,m5),c21=Matrix.add(m2,m4),c22=Matrix.sub(m1,m2);c22.add(m3),c22.add(m6);var resultat=Matrix.zeros(2*c11.rows,2*c11.columns);return(resultat=(resultat=(resultat=(resultat=resultat.setSubMatrix(c11,0,0)).setSubMatrix(c12,c11.rows,0)).setSubMatrix(c21,0,c11.columns)).setSubMatrix(c22,c11.rows,c11.columns)).subMatrix(0,rows-1,0,cols-1)}(x=embed(x,r,c),y=embed(y,r,c),r,c)}scaleRows(min,max$$1){if((min=void 0===min?0:min)>=(max$$1=void 0===max$$1?1:max$$1))throw new RangeError("min should be strictly smaller than max");for(var newMatrix=this.constructor.empty(this.rows,this.columns),i=0;i<this.rows;i++){var scaled=rescale(this.getRow(i),{min,max:max$$1});newMatrix.setRow(i,scaled)}return newMatrix}scaleColumns(min,max$$1){if((min=void 0===min?0:min)>=(max$$1=void 0===max$$1?1:max$$1))throw new RangeError("min should be strictly smaller than max");for(var newMatrix=this.constructor.empty(this.rows,this.columns),i=0;i<this.columns;i++){var scaled=rescale(this.getColumn(i),{min,max:max$$1});newMatrix.setColumn(i,scaled)}return newMatrix}kroneckerProduct(other){other=this.constructor.checkMatrix(other);for(var m=this.rows,n=this.columns,p=other.rows,q=other.columns,result=new this.constructor[Symbol.species](m*p,n*q),i=0;i<m;i++)for(var j=0;j<n;j++)for(var k=0;k<p;k++)for(var l=0;l<q;l++)result[p*i+k][q*j+l]=this.get(i,j)*other.get(k,l);return result}transpose(){for(var result=new this.constructor[Symbol.species](this.columns,this.rows),i=0;i<this.rows;i++)for(var j=0;j<this.columns;j++)result.set(j,i,this.get(i,j));return result}sortRows(compareFunction){void 0===compareFunction&&(compareFunction=compareNumbers);for(var i=0;i<this.rows;i++)this.setRow(i,this.getRow(i).sort(compareFunction));return this}sortColumns(compareFunction){void 0===compareFunction&&(compareFunction=compareNumbers);for(var i=0;i<this.columns;i++)this.setColumn(i,this.getColumn(i).sort(compareFunction));return this}subMatrix(startRow,endRow,startColumn,endColumn){checkRange(this,startRow,endRow,startColumn,endColumn);for(var newMatrix=new this.constructor[Symbol.species](endRow-startRow+1,endColumn-startColumn+1),i=startRow;i<=endRow;i++)for(var j=startColumn;j<=endColumn;j++)newMatrix[i-startRow][j-startColumn]=this.get(i,j);return newMatrix}subMatrixRow(indices,startColumn,endColumn){if(void 0===startColumn&&(startColumn=0),void 0===endColumn&&(endColumn=this.columns-1),startColumn>endColumn||startColumn<0||startColumn>=this.columns||endColumn<0||endColumn>=this.columns)throw new RangeError("Argument out of range");for(var newMatrix=new this.constructor[Symbol.species](indices.length,endColumn-startColumn+1),i=0;i<indices.length;i++)for(var j=startColumn;j<=endColumn;j++){if(indices[i]<0||indices[i]>=this.rows)throw new RangeError(`Row index out of range: ${indices[i]}`);newMatrix.set(i,j-startColumn,this.get(indices[i],j))}return newMatrix}subMatrixColumn(indices,startRow,endRow){if(void 0===startRow&&(startRow=0),void 0===endRow&&(endRow=this.rows-1),startRow>endRow||startRow<0||startRow>=this.rows||endRow<0||endRow>=this.rows)throw new RangeError("Argument out of range");for(var newMatrix=new this.constructor[Symbol.species](endRow-startRow+1,indices.length),i=0;i<indices.length;i++)for(var j=startRow;j<=endRow;j++){if(indices[i]<0||indices[i]>=this.columns)throw new RangeError(`Column index out of range: ${indices[i]}`);newMatrix.set(j-startRow,i,this.get(j,indices[i]))}return newMatrix}setSubMatrix(matrix,startRow,startColumn){checkRange(this,startRow,startRow+(matrix=this.constructor.checkMatrix(matrix)).rows-1,startColumn,startColumn+matrix.columns-1);for(var i=0;i<matrix.rows;i++)for(var j=0;j<matrix.columns;j++)this[startRow+i][startColumn+j]=matrix.get(i,j);return this}selection(rowIndices,columnIndices){for(var indices=checkIndices(this,rowIndices,columnIndices),newMatrix=new this.constructor[Symbol.species](rowIndices.length,columnIndices.length),i=0;i<indices.row.length;i++)for(var rowIndex=indices.row[i],j=0;j<indices.column.length;j++){var columnIndex=indices.column[j];newMatrix[i][j]=this.get(rowIndex,columnIndex)}return newMatrix}trace(){for(var min=Math.min(this.rows,this.columns),trace=0,i=0;i<min;i++)trace+=this.get(i,i);return trace}transposeView(){return new MatrixTransposeView(this)}rowView(row){return checkRowIndex(this,row),new MatrixRowView(this,row)}columnView(column){return checkColumnIndex(this,column),new MatrixColumnView(this,column)}flipRowView(){return new MatrixFlipRowView(this)}flipColumnView(){return new MatrixFlipColumnView(this)}subMatrixView(startRow,endRow,startColumn,endColumn){return new MatrixSubView(this,startRow,endRow,startColumn,endColumn)}selectionView(rowIndices,columnIndices){return new MatrixSelectionView(this,rowIndices,columnIndices)}rowSelectionView(rowIndices){return new MatrixRowSelectionView(this,rowIndices)}columnSelectionView(columnIndices){return new MatrixColumnSelectionView(this,columnIndices)}det(){var a,b,c,subMatrix0,subMatrix1,subMatrix2;if(this.isSquare())return 2===this.columns?(a=this.get(0,0),b=this.get(0,1),c=this.get(1,0),a*this.get(1,1)-b*c):3===this.columns?(subMatrix0=this.selectionView([1,2],[1,2]),subMatrix1=this.selectionView([1,2],[0,2]),subMatrix2=this.selectionView([1,2],[0,1]),a=this.get(0,0),b=this.get(0,1),c=this.get(0,2),a*subMatrix0.det()-b*subMatrix1.det()+c*subMatrix2.det()):new LuDecomposition$$1(this).determinant;throw Error("Determinant can only be calculated for a square matrix.")}pseudoInverse(threshold){void 0===threshold&&(threshold=Number.EPSILON);for(var svdSolution=new SingularValueDecomposition$$1(this,{autoTranspose:!0}),U=svdSolution.leftSingularVectors,V=svdSolution.rightSingularVectors,s=svdSolution.diagonal,i=0;i<s.length;i++)Math.abs(s[i])>threshold?s[i]=1/s[i]:s[i]=0;return s=this.constructor[Symbol.species].diag(s),V.mmul(s.mmul(U.transposeView()))}clone(){for(var newMatrix=new this.constructor[Symbol.species](this.rows,this.columns),row=0;row<this.rows;row++)for(var column=0;column<this.columns;column++)newMatrix.set(row,column,this.get(row,column));return newMatrix}}function compareNumbers(a,b){return a-b}Matrix.prototype.klass="Matrix",Matrix.random=Matrix.rand,Matrix.diagonal=Matrix.diag,Matrix.prototype.diagonal=Matrix.prototype.diag,Matrix.identity=Matrix.eye,Matrix.prototype.negate=Matrix.prototype.neg,Matrix.prototype.tensorProduct=Matrix.prototype.kroneckerProduct,Matrix.prototype.determinant=Matrix.prototype.det;var i,staticMethodWithArgs="\n(function %name%(matrix, %args%) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%(%args%);\n})\n",eval2=eval;for(var operator of[["+","add"],["-","sub","subtract"],["*","mul","multiply"],["/","div","divide"],["%","mod","modulus"],["&","and"],["|","or"],["^","xor"],["<<","leftShift"],[">>","signPropagatingRightShift"],[">>>","rightShift","zeroFillRightShift"]]){var inplaceOp=eval2(fillTemplateFunction("\n(function %name%(value) {\n    if (typeof value === 'number') return this.%name%S(value);\n    return this.%name%M(value);\n})\n",{name:operator[1],op:operator[0]})),inplaceOpS=eval2(fillTemplateFunction("\n(function %name%S(value) {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, this.get(i, j) %op% value);\n        }\n    }\n    return this;\n})\n",{name:`${operator[1]}S`,op:operator[0]})),inplaceOpM=eval2(fillTemplateFunction("\n(function %name%M(matrix) {\n    matrix = this.constructor.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n        this.columns !== matrix.columns) {\n        throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, this.get(i, j) %op% matrix.get(i, j));\n        }\n    }\n    return this;\n})\n",{name:`${operator[1]}M`,op:operator[0]})),staticOp=eval2(fillTemplateFunction("\n(function %name%(matrix, value) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%(value);\n})\n",{name:operator[1]}));for(i=1;i<operator.length;i++)Matrix.prototype[operator[i]]=inplaceOp,Matrix.prototype[`${operator[i]}S`]=inplaceOpS,Matrix.prototype[`${operator[i]}M`]=inplaceOpM,Matrix[operator[i]]=staticOp}var methods=[["~","not"]];for(var method of(["abs","acos","acosh","asin","asinh","atan","atanh","cbrt","ceil","clz32","cos","cosh","exp","expm1","floor","fround","log","log1p","log10","log2","round","sign","sin","sinh","sqrt","tan","tanh","trunc"].forEach(function(mathMethod){methods.push([`Math.${mathMethod}`,mathMethod])}),methods)){var inplaceMeth=eval2(fillTemplateFunction("\n(function %name%() {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j)));\n        }\n    }\n    return this;\n})\n",{name:method[1],method:method[0]})),staticMeth=eval2(fillTemplateFunction("\n(function %name%(matrix) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%();\n})\n",{name:method[1]}));for(i=1;i<method.length;i++)Matrix.prototype[method[i]]=inplaceMeth,Matrix[method[i]]=staticMeth}for(var methodWithArg of[["Math.pow",1,"pow"]]){var args="arg0";for(i=1;i<methodWithArg[1];i++)args+=`, arg${i}`;if(1!==methodWithArg[1]){var inplaceMethWithArgs=eval2(fillTemplateFunction("\n(function %name%(%args%) {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j), %args%));\n        }\n    }\n    return this;\n})\n",{name:methodWithArg[2],method:methodWithArg[0],args})),staticMethWithArgs=eval2(fillTemplateFunction(staticMethodWithArgs,{name:methodWithArg[2],args}));for(i=2;i<methodWithArg.length;i++)Matrix.prototype[methodWithArg[i]]=inplaceMethWithArgs,Matrix[methodWithArg[i]]=staticMethWithArgs}else{var tmplVar={name:methodWithArg[2],args,method:methodWithArg[0]},inplaceMethod2=eval2(fillTemplateFunction("\n(function %name%(value) {\n    if (typeof value === 'number') return this.%name%S(value);\n    return this.%name%M(value);\n})\n",tmplVar)),inplaceMethodS=eval2(fillTemplateFunction("\n(function %name%S(value) {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j), value));\n        }\n    }\n    return this;\n})\n",tmplVar)),inplaceMethodM=eval2(fillTemplateFunction("\n(function %name%M(matrix) {\n    matrix = this.constructor.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n        this.columns !== matrix.columns) {\n        throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j), matrix.get(i, j)));\n        }\n    }\n    return this;\n})\n",tmplVar)),staticMethod2=eval2(fillTemplateFunction("\n(function %name%(matrix, %args%) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%(%args%);\n})\n",tmplVar));for(i=2;i<methodWithArg.length;i++)Matrix.prototype[methodWithArg[i]]=inplaceMethod2,Matrix.prototype[`${methodWithArg[i]}M`]=inplaceMethodM,Matrix.prototype[`${methodWithArg[i]}S`]=inplaceMethodS,Matrix[methodWithArg[i]]=staticMethod2}}function fillTemplateFunction(template,values){for(var value in values)template=template.replace(new RegExp(`%${value}%`,"g"),values[value]);return template}return Matrix}class Matrix extends(AbstractMatrix(Array)){constructor(nRows,nColumns){var i;if(1===arguments.length&&"number"==typeof nRows)return new Array(nRows);if(Matrix.isMatrix(nRows))return nRows.clone();if(Number.isInteger(nRows)&&nRows>0){if(super(nRows),!(Number.isInteger(nColumns)&&nColumns>0))throw new TypeError("nColumns must be a positive integer");for(i=0;i<nRows;i++)this[i]=new Array(nColumns)}else{if(!Array.isArray(nRows))throw new TypeError("First argument must be a positive number or an array");{const matrix=nRows;if(nRows=matrix.length,"number"!=typeof(nColumns=matrix[0].length)||0===nColumns)throw new TypeError("Data must be a 2D array with at least one element");for(super(nRows),i=0;i<nRows;i++){if(matrix[i].length!==nColumns)throw new RangeError("Inconsistent array dimensions");this[i]=[].concat(matrix[i])}}}return this.rows=nRows,this.columns=nColumns,this}set(rowIndex,columnIndex,value){return this[rowIndex][columnIndex]=value,this}get(rowIndex,columnIndex){return this[rowIndex][columnIndex]}removeRow(index){if(checkRowIndex(this,index),1===this.rows)throw new RangeError("A matrix cannot have less than one row");return this.splice(index,1),this.rows-=1,this}addRow(index,array){return void 0===array&&(array=index,index=this.rows),checkRowIndex(this,index,!0),array=checkRowVector(this,array),this.splice(index,0,array),this.rows+=1,this}removeColumn(index){if(checkColumnIndex(this,index),1===this.columns)throw new RangeError("A matrix cannot have less than one column");for(var i=0;i<this.rows;i++)this[i].splice(index,1);return this.columns-=1,this}addColumn(index,array){void 0===array&&(array=index,index=this.columns),checkColumnIndex(this,index,!0),array=checkColumnVector(this,array);for(var i=0;i<this.rows;i++)this[i].splice(index,0,array[i]);return this.columns+=1,this}}class WrapperMatrix1D extends(AbstractMatrix()){constructor(data,options={}){const{rows=1}=options;if(data.length%rows!=0)throw new Error("the data length is not divisible by the number of rows");super(),this.rows=rows,this.columns=data.length/rows,this.data=data}set(rowIndex,columnIndex,value){var index=this._calculateIndex(rowIndex,columnIndex);return this.data[index]=value,this}get(rowIndex,columnIndex){var index=this._calculateIndex(rowIndex,columnIndex);return this.data[index]}_calculateIndex(row,column){return row*this.columns+column}static get[Symbol.species](){return Matrix}}class WrapperMatrix2D extends(AbstractMatrix()){constructor(data){super(),this.data=data,this.rows=data.length,this.columns=data[0].length}set(rowIndex,columnIndex,value){return this.data[rowIndex][columnIndex]=value,this}get(rowIndex,columnIndex){return this.data[rowIndex][columnIndex]}static get[Symbol.species](){return Matrix}}class QrDecomposition$$1{constructor(value){var i,j,k,s,qr=(value=WrapperMatrix2D.checkMatrix(value)).clone(),m=value.rows,n=value.columns,rdiag=new Array(n);for(k=0;k<n;k++){var nrm=0;for(i=k;i<m;i++)nrm=hypotenuse(nrm,qr.get(i,k));if(0!==nrm){for(qr.get(k,k)<0&&(nrm=-nrm),i=k;i<m;i++)qr.set(i,k,qr.get(i,k)/nrm);for(qr.set(k,k,qr.get(k,k)+1),j=k+1;j<n;j++){for(s=0,i=k;i<m;i++)s+=qr.get(i,k)*qr.get(i,j);for(s=-s/qr.get(k,k),i=k;i<m;i++)qr.set(i,j,qr.get(i,j)+s*qr.get(i,k))}}rdiag[k]=-nrm}this.QR=qr,this.Rdiag=rdiag}solve(value){value=Matrix.checkMatrix(value);var qr=this.QR,m=qr.rows;if(value.rows!==m)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");var i,j,k,s,count=value.columns,X=value.clone(),n=qr.columns;for(k=0;k<n;k++)for(j=0;j<count;j++){for(s=0,i=k;i<m;i++)s+=qr[i][k]*X[i][j];for(s=-s/qr[k][k],i=k;i<m;i++)X[i][j]+=s*qr[i][k]}for(k=n-1;k>=0;k--){for(j=0;j<count;j++)X[k][j]/=this.Rdiag[k];for(i=0;i<k;i++)for(j=0;j<count;j++)X[i][j]-=X[k][j]*qr[i][k]}return X.subMatrix(0,n-1,0,count-1)}isFullRank(){for(var columns=this.QR.columns,i=0;i<columns;i++)if(0===this.Rdiag[i])return!1;return!0}get upperTriangularMatrix(){var i,j,qr=this.QR,n=qr.columns,X=new Matrix(n,n);for(i=0;i<n;i++)for(j=0;j<n;j++)X[i][j]=i<j?qr[i][j]:i===j?this.Rdiag[i]:0;return X}get orthogonalMatrix(){var i,j,k,s,qr=this.QR,rows=qr.rows,columns=qr.columns,X=new Matrix(rows,columns);for(k=columns-1;k>=0;k--){for(i=0;i<rows;i++)X[i][k]=0;for(X[k][k]=1,j=k;j<columns;j++)if(0!==qr[k][k]){for(s=0,i=k;i<rows;i++)s+=qr[i][k]*X[i][j];for(s=-s/qr[k][k],i=k;i<rows;i++)X[i][j]+=s*qr[i][k]}}return X}}function solve$$1(leftHandSide,rightHandSide,useSVD=!1){return leftHandSide=WrapperMatrix2D.checkMatrix(leftHandSide),rightHandSide=WrapperMatrix2D.checkMatrix(rightHandSide),useSVD?new SingularValueDecomposition$$1(leftHandSide).solve(rightHandSide):leftHandSide.isSquare()?new LuDecomposition$$1(leftHandSide).solve(rightHandSide):new QrDecomposition$$1(leftHandSide).solve(rightHandSide)}function xrange(n,exception){for(var range=[],i=0;i<n;i++)i!==exception&&range.push(i);return range}function dependenciesOneRow(error,matrix,index,thresholdValue=1e-9,thresholdError=1e-9){if(error>thresholdError)return new Array(matrix.rows+1).fill(0);for(var returnArray=matrix.addRow(index,[0]),i=0;i<returnArray.rows;i++)Math.abs(returnArray.get(i,0))<thresholdValue&&returnArray.set(i,0,0);return returnArray.to1DArray()}class EigenvalueDecomposition$$1{constructor(matrix,options={}){const{assumeSymmetric=!1}=options;if(!(matrix=WrapperMatrix2D.checkMatrix(matrix)).isSquare())throw new Error("Matrix is not a square matrix");var i,j,n=matrix.columns,V=getFilled2DArray(n,n,0),d=new Array(n),e=new Array(n),value=matrix;if(!!assumeSymmetric||matrix.isSymmetric()){for(i=0;i<n;i++)for(j=0;j<n;j++)V[i][j]=value.get(i,j);!function(n,e,d,V){var f,g,h,i,j,k,hh,scale;for(j=0;j<n;j++)d[j]=V[n-1][j];for(i=n-1;i>0;i--){for(scale=0,h=0,k=0;k<i;k++)scale+=Math.abs(d[k]);if(0===scale)for(e[i]=d[i-1],j=0;j<i;j++)d[j]=V[i-1][j],V[i][j]=0,V[j][i]=0;else{for(k=0;k<i;k++)d[k]/=scale,h+=d[k]*d[k];for(f=d[i-1],g=Math.sqrt(h),f>0&&(g=-g),e[i]=scale*g,h-=f*g,d[i-1]=f-g,j=0;j<i;j++)e[j]=0;for(j=0;j<i;j++){for(f=d[j],V[j][i]=f,g=e[j]+V[j][j]*f,k=j+1;k<=i-1;k++)g+=V[k][j]*d[k],e[k]+=V[k][j]*f;e[j]=g}for(f=0,j=0;j<i;j++)e[j]/=h,f+=e[j]*d[j];for(hh=f/(h+h),j=0;j<i;j++)e[j]-=hh*d[j];for(j=0;j<i;j++){for(f=d[j],g=e[j],k=j;k<=i-1;k++)V[k][j]-=f*e[k]+g*d[k];d[j]=V[i-1][j],V[i][j]=0}}d[i]=h}for(i=0;i<n-1;i++){if(V[n-1][i]=V[i][i],V[i][i]=1,0!==(h=d[i+1])){for(k=0;k<=i;k++)d[k]=V[k][i+1]/h;for(j=0;j<=i;j++){for(g=0,k=0;k<=i;k++)g+=V[k][i+1]*V[k][j];for(k=0;k<=i;k++)V[k][j]-=g*d[k]}}for(k=0;k<=i;k++)V[k][i+1]=0}for(j=0;j<n;j++)d[j]=V[n-1][j],V[n-1][j]=0;V[n-1][n-1]=1,e[0]=0}(n,e,d,V),function(n,e,d,V){var g,h,i,j,k,l,m,p,r,dl1,c,c2,c3,el1,s,s2;for(i=1;i<n;i++)e[i-1]=e[i];e[n-1]=0;var f=0,tst1=0,eps=Number.EPSILON;for(l=0;l<n;l++){for(tst1=Math.max(tst1,Math.abs(d[l])+Math.abs(e[l])),m=l;m<n&&!(Math.abs(e[m])<=eps*tst1);)m++;if(m>l)do{for(g=d[l],p=(d[l+1]-g)/(2*e[l]),r=hypotenuse(p,1),p<0&&(r=-r),d[l]=e[l]/(p+r),d[l+1]=e[l]*(p+r),dl1=d[l+1],h=g-d[l],i=l+2;i<n;i++)d[i]-=h;for(f+=h,p=d[m],c2=c=1,c3=c,el1=e[l+1],s=0,s2=0,i=m-1;i>=l;i--)for(c3=c2,c2=c,s2=s,g=c*e[i],h=c*p,r=hypotenuse(p,e[i]),e[i+1]=s*r,s=e[i]/r,p=(c=p/r)*d[i]-s*g,d[i+1]=h+s*(c*g+s*d[i]),k=0;k<n;k++)h=V[k][i+1],V[k][i+1]=s*V[k][i]+c*h,V[k][i]=c*V[k][i]-s*h;p=-s*s2*c3*el1*e[l]/dl1,e[l]=s*p,d[l]=c*p}while(Math.abs(e[l])>eps*tst1);d[l]=d[l]+f,e[l]=0}for(i=0;i<n-1;i++){for(k=i,p=d[i],j=i+1;j<n;j++)d[j]<p&&(k=j,p=d[j]);if(k!==i)for(d[k]=d[i],d[i]=p,j=0;j<n;j++)p=V[j][i],V[j][i]=V[j][k],V[j][k]=p}}(n,e,d,V)}else{var H=getFilled2DArray(n,n,0),ort=new Array(n);for(j=0;j<n;j++)for(i=0;i<n;i++)H[i][j]=value.get(i,j);!function(n,H,ort,V){var f,g,h,i,j,m,scale,high=n-1;for(m=1;m<=high-1;m++){for(scale=0,i=m;i<=high;i++)scale+=Math.abs(H[i][m-1]);if(0!==scale){for(h=0,i=high;i>=m;i--)ort[i]=H[i][m-1]/scale,h+=ort[i]*ort[i];for(g=Math.sqrt(h),ort[m]>0&&(g=-g),h-=ort[m]*g,ort[m]=ort[m]-g,j=m;j<n;j++){for(f=0,i=high;i>=m;i--)f+=ort[i]*H[i][j];for(f/=h,i=m;i<=high;i++)H[i][j]-=f*ort[i]}for(i=0;i<=high;i++){for(f=0,j=high;j>=m;j--)f+=ort[j]*H[i][j];for(f/=h,j=m;j<=high;j++)H[i][j]-=f*ort[j]}ort[m]=scale*ort[m],H[m][m-1]=scale*g}}for(i=0;i<n;i++)for(j=0;j<n;j++)V[i][j]=i===j?1:0;for(m=high-1;m>=1;m--)if(0!==H[m][m-1]){for(i=m+1;i<=high;i++)ort[i]=H[i][m-1];for(j=m;j<=high;j++){for(g=0,i=m;i<=high;i++)g+=ort[i]*V[i][j];for(g=g/ort[m]/H[m][m-1],i=m;i<=high;i++)V[i][j]+=g*ort[i]}}}(n,H,ort,V),function(nn,e,d,V,H){var i,j,k,l,m,t,w,x,y,ra,sa,vr,vi,notlast,cdivres,n=nn-1,high=nn-1,eps=Number.EPSILON,exshift=0,norm=0,p=0,q=0,r=0,s=0,z=0,iter=0;for(i=0;i<nn;i++)for((i<0||i>high)&&(d[i]=H[i][i],e[i]=0),j=Math.max(i-1,0);j<nn;j++)norm+=Math.abs(H[i][j]);for(;n>=0;){for(l=n;l>0&&(0===(s=Math.abs(H[l-1][l-1])+Math.abs(H[l][l]))&&(s=norm),!(Math.abs(H[l][l-1])<eps*s));)l--;if(l===n)H[n][n]=H[n][n]+exshift,d[n]=H[n][n],e[n]=0,n--,iter=0;else if(l===n-1){if(w=H[n][n-1]*H[n-1][n],p=(H[n-1][n-1]-H[n][n])/2,q=p*p+w,z=Math.sqrt(Math.abs(q)),H[n][n]=H[n][n]+exshift,H[n-1][n-1]=H[n-1][n-1]+exshift,x=H[n][n],q>=0){for(z=p>=0?p+z:p-z,d[n-1]=x+z,d[n]=d[n-1],0!==z&&(d[n]=x-w/z),e[n-1]=0,e[n]=0,x=H[n][n-1],s=Math.abs(x)+Math.abs(z),p=x/s,q=z/s,r=Math.sqrt(p*p+q*q),p/=r,q/=r,j=n-1;j<nn;j++)z=H[n-1][j],H[n-1][j]=q*z+p*H[n][j],H[n][j]=q*H[n][j]-p*z;for(i=0;i<=n;i++)z=H[i][n-1],H[i][n-1]=q*z+p*H[i][n],H[i][n]=q*H[i][n]-p*z;for(i=0;i<=high;i++)z=V[i][n-1],V[i][n-1]=q*z+p*V[i][n],V[i][n]=q*V[i][n]-p*z}else d[n-1]=x+p,d[n]=x+p,e[n-1]=z,e[n]=-z;n-=2,iter=0}else{if(x=H[n][n],y=0,w=0,l<n&&(y=H[n-1][n-1],w=H[n][n-1]*H[n-1][n]),10===iter){for(exshift+=x,i=0;i<=n;i++)H[i][i]-=x;s=Math.abs(H[n][n-1])+Math.abs(H[n-1][n-2]),x=y=.75*s,w=-.4375*s*s}if(30===iter&&(s=(s=(y-x)/2)*s+w)>0){for(s=Math.sqrt(s),y<x&&(s=-s),s=x-w/((y-x)/2+s),i=0;i<=n;i++)H[i][i]-=s;exshift+=s,x=y=w=.964}for(iter+=1,m=n-2;m>=l&&(z=H[m][m],p=((r=x-z)*(s=y-z)-w)/H[m+1][m]+H[m][m+1],q=H[m+1][m+1]-z-r-s,r=H[m+2][m+1],s=Math.abs(p)+Math.abs(q)+Math.abs(r),p/=s,q/=s,r/=s,m!==l)&&!(Math.abs(H[m][m-1])*(Math.abs(q)+Math.abs(r))<eps*(Math.abs(p)*(Math.abs(H[m-1][m-1])+Math.abs(z)+Math.abs(H[m+1][m+1]))));)m--;for(i=m+2;i<=n;i++)H[i][i-2]=0,i>m+2&&(H[i][i-3]=0);for(k=m;k<=n-1&&(notlast=k!==n-1,k!==m&&(p=H[k][k-1],q=H[k+1][k-1],r=notlast?H[k+2][k-1]:0,0!==(x=Math.abs(p)+Math.abs(q)+Math.abs(r))&&(p/=x,q/=x,r/=x)),0!==x);k++)if(s=Math.sqrt(p*p+q*q+r*r),p<0&&(s=-s),0!==s){for(k!==m?H[k][k-1]=-s*x:l!==m&&(H[k][k-1]=-H[k][k-1]),x=(p+=s)/s,y=q/s,z=r/s,q/=p,r/=p,j=k;j<nn;j++)p=H[k][j]+q*H[k+1][j],notlast&&(p+=r*H[k+2][j],H[k+2][j]=H[k+2][j]-p*z),H[k][j]=H[k][j]-p*x,H[k+1][j]=H[k+1][j]-p*y;for(i=0;i<=Math.min(n,k+3);i++)p=x*H[i][k]+y*H[i][k+1],notlast&&(p+=z*H[i][k+2],H[i][k+2]=H[i][k+2]-p*r),H[i][k]=H[i][k]-p,H[i][k+1]=H[i][k+1]-p*q;for(i=0;i<=high;i++)p=x*V[i][k]+y*V[i][k+1],notlast&&(p+=z*V[i][k+2],V[i][k+2]=V[i][k+2]-p*r),V[i][k]=V[i][k]-p,V[i][k+1]=V[i][k+1]-p*q}}}if(0===norm)return;for(n=nn-1;n>=0;n--)if(p=d[n],0===(q=e[n]))for(l=n,H[n][n]=1,i=n-1;i>=0;i--){for(w=H[i][i]-p,r=0,j=l;j<=n;j++)r+=H[i][j]*H[j][n];if(e[i]<0)z=w,s=r;else if(l=i,0===e[i]?H[i][n]=0!==w?-r/w:-r/(eps*norm):(x=H[i][i+1],y=H[i+1][i],q=(d[i]-p)*(d[i]-p)+e[i]*e[i],t=(x*s-z*r)/q,H[i][n]=t,H[i+1][n]=Math.abs(x)>Math.abs(z)?(-r-w*t)/x:(-s-y*t)/z),t=Math.abs(H[i][n]),eps*t*t>1)for(j=i;j<=n;j++)H[j][n]=H[j][n]/t}else if(q<0)for(l=n-1,Math.abs(H[n][n-1])>Math.abs(H[n-1][n])?(H[n-1][n-1]=q/H[n][n-1],H[n-1][n]=-(H[n][n]-p)/H[n][n-1]):(cdivres=cdiv(0,-H[n-1][n],H[n-1][n-1]-p,q),H[n-1][n-1]=cdivres[0],H[n-1][n]=cdivres[1]),H[n][n-1]=0,H[n][n]=1,i=n-2;i>=0;i--){for(ra=0,sa=0,j=l;j<=n;j++)ra+=H[i][j]*H[j][n-1],sa+=H[i][j]*H[j][n];if(w=H[i][i]-p,e[i]<0)z=w,r=ra,s=sa;else if(l=i,0===e[i]?(cdivres=cdiv(-ra,-sa,w,q),H[i][n-1]=cdivres[0],H[i][n]=cdivres[1]):(x=H[i][i+1],y=H[i+1][i],vr=(d[i]-p)*(d[i]-p)+e[i]*e[i]-q*q,vi=2*(d[i]-p)*q,0===vr&&0===vi&&(vr=eps*norm*(Math.abs(w)+Math.abs(q)+Math.abs(x)+Math.abs(y)+Math.abs(z))),cdivres=cdiv(x*r-z*ra+q*sa,x*s-z*sa-q*ra,vr,vi),H[i][n-1]=cdivres[0],H[i][n]=cdivres[1],Math.abs(x)>Math.abs(z)+Math.abs(q)?(H[i+1][n-1]=(-ra-w*H[i][n-1]+q*H[i][n])/x,H[i+1][n]=(-sa-w*H[i][n]-q*H[i][n-1])/x):(cdivres=cdiv(-r-y*H[i][n-1],-s-y*H[i][n],z,q),H[i+1][n-1]=cdivres[0],H[i+1][n]=cdivres[1])),t=Math.max(Math.abs(H[i][n-1]),Math.abs(H[i][n])),eps*t*t>1)for(j=i;j<=n;j++)H[j][n-1]=H[j][n-1]/t,H[j][n]=H[j][n]/t}for(i=0;i<nn;i++)if(i<0||i>high)for(j=i;j<nn;j++)V[i][j]=H[i][j];for(j=nn-1;j>=0;j--)for(i=0;i<=high;i++){for(z=0,k=0;k<=Math.min(j,high);k++)z+=V[i][k]*H[k][j];V[i][j]=z}}(n,e,d,V,H)}this.n=n,this.e=e,this.d=d,this.V=V}get realEigenvalues(){return this.d}get imaginaryEigenvalues(){return this.e}get eigenvectorMatrix(){return Matrix.isMatrix(this.V)||(this.V=new Matrix(this.V)),this.V}get diagonalMatrix(){var i,j,n=this.n,e=this.e,d=this.d,X=new Matrix(n,n);for(i=0;i<n;i++){for(j=0;j<n;j++)X[i][j]=0;X[i][i]=d[i],e[i]>0?X[i][i+1]=e[i]:e[i]<0&&(X[i][i-1]=e[i])}return X}}function cdiv(xr,xi,yr,yi){var r,d;return Math.abs(yr)>Math.abs(yi)?[(xr+(r=yi/yr)*xi)/(d=yr+r*yi),(xi-r*xr)/d]:[((r=yr/yi)*xr+xi)/(d=yi+r*yr),(r*xi-xr)/d]}class CholeskyDecomposition$$1{constructor(value){if(!(value=WrapperMatrix2D.checkMatrix(value)).isSymmetric())throw new Error("Matrix is not symmetric");var i,j,k,a=value,dimension=a.rows,l=new Matrix(dimension,dimension),positiveDefinite=!0;for(j=0;j<dimension;j++){var Lrowj=l[j],d=0;for(k=0;k<j;k++){var Lrowk=l[k],s=0;for(i=0;i<k;i++)s+=Lrowk[i]*Lrowj[i];Lrowj[k]=s=(a.get(j,k)-s)/l[k][k],d+=s*s}for(positiveDefinite&=(d=a.get(j,j)-d)>0,l[j][j]=Math.sqrt(Math.max(d,0)),k=j+1;k<dimension;k++)l[j][k]=0}if(!positiveDefinite)throw new Error("Matrix is not positive definite");this.L=l}solve(value){value=WrapperMatrix2D.checkMatrix(value);var l=this.L,dimension=l.rows;if(value.rows!==dimension)throw new Error("Matrix dimensions do not match");var i,j,k,count=value.columns,B=value.clone();for(k=0;k<dimension;k++)for(j=0;j<count;j++){for(i=0;i<k;i++)B[k][j]-=B[i][j]*l[k][i];B[k][j]/=l[k][k]}for(k=dimension-1;k>=0;k--)for(j=0;j<count;j++){for(i=k+1;i<dimension;i++)B[k][j]-=B[i][j]*l[i][k];B[k][j]/=l[k][k]}return B}get lowerTriangularMatrix(){return this.L}}exports.default=Matrix,exports.Matrix=Matrix,exports.abstractMatrix=AbstractMatrix,exports.wrap=function(array,options){if(Array.isArray(array))return array[0]&&Array.isArray(array[0])?new WrapperMatrix2D(array):new WrapperMatrix1D(array,options);throw new Error("the argument is not an array")},exports.WrapperMatrix2D=WrapperMatrix2D,exports.WrapperMatrix1D=WrapperMatrix1D,exports.solve=solve$$1,exports.inverse=function(matrix,useSVD=!1){return matrix=WrapperMatrix2D.checkMatrix(matrix),useSVD?new SingularValueDecomposition$$1(matrix).inverse():solve$$1(matrix,Matrix.eye(matrix.rows))},exports.linearDependencies=function(matrix,options={}){const{thresholdValue=1e-9,thresholdError=1e-9}=options;for(var n=matrix.rows,results=new Matrix(n,n),i=0;i<n;i++){var b=Matrix.columnVector(matrix.getRow(i)),Abis=matrix.subMatrixRow(xrange(n,i)).transposeView(),x=new SingularValueDecomposition$$1(Abis).solve(b),error=max(Matrix.sub(b,Abis.mmul(x)).abs().to1DArray());results.setRow(i,dependenciesOneRow(error,x,i,thresholdValue,thresholdError))}return results},exports.SingularValueDecomposition=SingularValueDecomposition$$1,exports.SVD=SingularValueDecomposition$$1,exports.EigenvalueDecomposition=EigenvalueDecomposition$$1,exports.EVD=EigenvalueDecomposition$$1,exports.CholeskyDecomposition=CholeskyDecomposition$$1,exports.CHO=CholeskyDecomposition$$1,exports.LuDecomposition=LuDecomposition$$1,exports.LU=LuDecomposition$$1,exports.QrDecomposition=QrDecomposition$$1,exports.QR=QrDecomposition$$1},{"ml-array-max":2,"ml-array-rescale":4}]},{},[1])(1)});